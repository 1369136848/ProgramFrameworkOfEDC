C51 COMPILER V8.05a   DATASCOPE_DP                                                         07/01/2017 18:07:23 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE DATASCOPE_DP
OBJECT MODULE PLACED IN .\DataScope_DP.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\SOFTWARE\COMMON_SOFTWARE\DATA_SCOPE\DataScope_DP.c LARGE BROWSE DEBUG
                    - OBJECTEXTEND PRINT(.\DataScope_DP.lst) TABS(2) OBJECT(.\DataScope_DP.obj)

line level    source

   1          /************************************************************
   2          * 组织名称： 电子大赛小组
   3          * 文件名称: DataScope_DP.c
   4          * 作者:  未知
   5          * 版本 :1.1
   6          * 日期:
   7          * 主要功能 :
   8          * 向上位机发送数据的文件
   9          * 历史修改记录: // 历史修改记录
  10          * <作者> <时间> <版本 > <描述>
  11          ***********************************************************/
  12          /***************串口示波器驱动代码************************/
  13          #include "DataScope_DP.h"
  14          #define DATA_SCOPE
  15          #ifdef DATA_SCOPE
  16          
  17          unsigned char DataScope_OutPut_Buffer[42] = {0};       //串口发送缓冲区
  18          //函数说明：将单精度浮点数据转成4字节数据并存入指定地址
  19          //附加说明：用户无需直接操作此函数
  20          //target:目标单精度数据
  21          //buf:待写入数组
  22          //beg:指定从数组第几个元素开始写入
  23          //函数无返回
  24          //对此函数进行了修改，原本是有问题的，后来发现point数组的顺序反了，现在能正常使用了
  25           void Float2Byte(float *target,unsigned char *buf,unsigned char beg)
  26          {
  27   1        unsigned char *point;
  28   1        point = (unsigned char*)target;   //得到float的地址
  29   1        buf[beg]   = point[3];
  30   1        buf[beg+1] = point[2];
  31   1        buf[beg+2] = point[1];
  32   1        buf[beg+3] = point[0];
  33   1      }
  34          //函数说明：将待发送通道的单精度浮点数据写入发送缓冲区
  35          //Data：通道数据
  36          //Channel：选择通道（1-10）
  37          //函数无返回
  38          void DataScope_Get_Channel_Data(float Data,unsigned char Channel)
  39          {
  40   1        if ( (Channel > 10) || (Channel == 0) )
  41   1          {
  42   2            return;    //通道个数大于10或等于0，直接跳出，不执行函数
  43   2          }
  44   1        else
  45   1          {
  46   2            switch (Channel)
  47   2              {
  48   3                case 1:
  49   3                  Float2Byte(&Data,DataScope_OutPut_Buffer,1);
  50   3                  break;
  51   3                case 2:
  52   3                  Float2Byte(&Data,DataScope_OutPut_Buffer,5);
  53   3                  break;
  54   3                case 3:
C51 COMPILER V8.05a   DATASCOPE_DP                                                         07/01/2017 18:07:23 PAGE 2   

  55   3                  Float2Byte(&Data,DataScope_OutPut_Buffer,9);
  56   3                  break;
  57   3                case 4:
  58   3                  Float2Byte(&Data,DataScope_OutPut_Buffer,13);
  59   3                  break;
  60   3                case 5:
  61   3                  Float2Byte(&Data,DataScope_OutPut_Buffer,17);
  62   3                  break;
  63   3                case 6:
  64   3                  Float2Byte(&Data,DataScope_OutPut_Buffer,21);
  65   3                  break;
  66   3                case 7:
  67   3                  Float2Byte(&Data,DataScope_OutPut_Buffer,25);
  68   3                  break;
  69   3                case 8:
  70   3                  Float2Byte(&Data,DataScope_OutPut_Buffer,29);
  71   3                  break;
  72   3                case 9:
  73   3                  Float2Byte(&Data,DataScope_OutPut_Buffer,33);
  74   3                  break;
  75   3                case 10:
  76   3                  Float2Byte(&Data,DataScope_OutPut_Buffer,37);
  77   3                  break;
  78   3              }
  79   2          }
  80   1      }
  81          //函数说明：生成 DataScopeV1.0 能正确识别的帧格式
  82          //Channel_Number，需要发送的通道个数
  83          //返回发送缓冲区数据个数
  84          //返回0表示帧格式生成失败
  85          unsigned char DataScope_Data_Generate(unsigned char Channel_Number)
  86          {
  87   1        if ( (Channel_Number > 10) || (Channel_Number == 0) )
  88   1          {
  89   2            return 0;    //通道个数大于10或等于0，直接跳出，不执行函数
  90   2          }
  91   1        else
  92   1          {
  93   2            DataScope_OutPut_Buffer[0] = '$';  //帧头
  94   2            switch(Channel_Number)
  95   2              {
  96   3                case 1:
  97   3                  DataScope_OutPut_Buffer[5]  =  5;
  98   3                  return  6;
  99   3                  break;
 100   3                case 2:
 101   3                  DataScope_OutPut_Buffer[9]  =  9;
 102   3                  return 10;
 103   3                  break;
 104   3                case 3:
 105   3                  DataScope_OutPut_Buffer[13] = 13;
 106   3                  return 14;
 107   3                  break;
 108   3                case 4:
 109   3                  DataScope_OutPut_Buffer[17] = 17;
 110   3                  return 18;
 111   3                  break;
 112   3                case 5:
 113   3                  DataScope_OutPut_Buffer[21] = 21;
 114   3                  return 22;
 115   3                  break;
 116   3                case 6:
C51 COMPILER V8.05a   DATASCOPE_DP                                                         07/01/2017 18:07:23 PAGE 3   

 117   3                  DataScope_OutPut_Buffer[25] = 25;
 118   3                  return 26;
 119   3                  break;
 120   3                case 7:
 121   3                  DataScope_OutPut_Buffer[29] = 29;
 122   3                  return 30;
 123   3                  break;
 124   3                case 8:
 125   3                  DataScope_OutPut_Buffer[33] = 33;
 126   3                  return 34;
 127   3                  break;
 128   3                case 9:
 129   3                  DataScope_OutPut_Buffer[37] = 37;
 130   3                  return 38;
 131   3                  break;
 132   3                case 10:
 133   3                  DataScope_OutPut_Buffer[41] = 41;
 134   3                  return 42;
 135   3                  break;
 136   3              }
 137   2          }
 138   1        return 0;
 139   1      }
 140          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    643    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     42      15
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
