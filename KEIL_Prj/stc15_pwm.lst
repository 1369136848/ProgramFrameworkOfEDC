C51 COMPILER V8.05a   STC15_PWM                                                            07/17/2017 11:46:44 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE STC15_PWM
OBJECT MODULE PLACED IN .\stc15_pwm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\BSP\stc15_pwm.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\stc1
                    -5_pwm.lst) TABS(2) OBJECT(.\stc15_pwm.obj)

line level    source

   1          /************************************************************
   2          * ×éÖ¯Ãû³Æ£º (C), 1988-1999, Tech. Co., Ltd.
   3          * ÎÄ¼þÃû³Æ: STC15_PWM.C
   4          * ×÷Õß:  ÖÜ³¿Ñô
   5          * °æ±¾:  1.3
   6          * ÈÕÆÚ:  2017/4/27
   7          * ÃèÊö:  Ó²¼þpwmµÄ¿âº¯Êý£¬io¿Ú²Î¼ûÏÂ·½½éÉÜ
   8          * ÀúÊ·ÐÞ¸Ä¼ÇÂ¼: // ÀúÊ·ÐÞ¸Ä¼ÇÂ¼
   9          * <×÷Õß> <Ê±¼ä> <°æ±¾ > <ÃèÊö>
  10          * ÖÜ³¿Ñô 2017/4/27 1.1 ÐÞ¸ÄÁËÒ»´¦´úÂë´íÎó£¬case²ÎÊý´íÎó
  11          * ÖÜ³¿Ñô 2017/5/6  1.2 Ôö¼ÓÁËÒ»Ð©³£ÓÃÉèÖÃº¯Êý
  12          * ÖÜ³¿Ñô 2017/7/9  1.3 ÐÞ¸ÄÁËpwmÐÅÏ¢µÄ¼ÇÂ¼ºÍ·µ»Ø·½Ê½£¬Ê¹ÓÃ½á¹¹ÌåÊý×éÀ´´æ·ÅÐÅÏ¢
  13          ***********************************************************/
  14          
  15          #include "stc15_pwm.h"
  16          #include "GPIO.h"
  17          //PWMÐÅÏ¢´æ´¢
  18          /************************************
  19          Ó²¼þPWMioÒý½Å
  20          PWM_N| io  | µÚ¶þ×é
  21          PWM2 :P3.7 -> P2.7
  22          PWM3 :P2.1 -> P4.5
  23          PWM4 :P2.2 -> P4.4
  24          PWM5 :P2.3 -> P4.2
  25          PWM6 :P1.6 -> P0.7
  26          PWM7 :P1.7 -> P0.6
  27          ************************************/
  28          
  29          static struct PWM_N_INFO
  30          {
  31            u32 period;//pwmµÄÆµÂÊ
  32            u8 state;//pwm·¢ÉúÆ÷µÄ×´Ì¬
  33            float duty;//pwmµÄÕ¼¿Õ±È
  34          };
  35          static  struct PWM_N_INFO PWM_N_INFO[6]; //6×épwmÊý¾Ý´æ´¢
  36          
  37          //========================================================================
  38          //u8    PWM_Inilize(PWM_InitTypeDef *PWM)
  39          // ÃèÊö:PWM³õÊ¼»¯³ÌÐò
  40          // ²ÎÊý:u8 PWM_N:PWMÂ·Êý±êºÅ(2~7) PWM: ½á¹¹²ÎÊý,Çë²Î¿¼pwm.hÀïµÄ¶¨Òå.
  41          // ·µ»Ø: ³É¹¦·µ»Ø0, ´íÎó·µ»Ø1
  42          //========================================================================
  43          void PWM_Inilize(u8 PWM_N, PWM_InitTypeDef *PWMx)
  44          {
  45   1        u8 i = 0;
  46   1        for (; i < 6; i++)
  47   1        {
  48   2          PWM_N_INFO[i].period = 0;
  49   2          PWM_N_INFO[i].state = 0;
  50   2          PWM_N_INFO[i].duty = 0;
  51   2        }
  52   1      
  53   1        P_SW2 |= 0X80;
  54   1        if (ENABLE == PWMx->PWM_GOTO_ADC)            //ENABLE=¼ÆÊýÆ÷¹éÁãÊ± ´¥·¢ADC
C51 COMPILER V8.05a   STC15_PWM                                                            07/17/2017 11:46:44 PAGE 2   

  55   1        {
  56   2          PWMCFG |= (1 << 7); //²¢µÄÒâË¼¾ÍÊÇ²»»á¸Ä±äÆäËûÎ»µÄÖµ
  57   2        }
  58   1        else
  59   1        {
  60   2          PWMCFG &= (~(1 << 7)); //ÆäÊµÒ²¿ÉÒÔÓÃÉÏ±ßµÄ°ì·¨£¬µ«ÊÇÕâÑùÐ´µÄÒâË¼¸üÖ±¹Û
  61   2        }
  62   1        if (PWM_HIGHT == PWMx->PWM_V_INIT)              //PWM_HIGHT=³õÊ¼¸ßµçÆ½     PWM_LOW=³õÊ¼µÍµçÆ½
  63   1        {
  64   2          PWMCFG |= (1 << PWM_N);
  65   2        }
  66   1        else
  67   1        {
  68   2          PWMCFG &= (~(1 << PWM_N));
  69   2        }
  70   1        if (ENABLE == PWMx->PWM_0ISR_EN)             //ENABLE=Ê¹ÄÜPWM¼ÆÊýÆ÷¹éÁãÖÐ¶Ï  DISABLE=¹Ø±ÕPWM¼ÆÊýÆ÷¹éÁãÖÐ¶
             -Ï µ« CBIFÈÔÈ»»á±»Ó²¼þÖÃÎ»
  71   1        {
  72   2          PWMCR |= (1 << 6);
  73   2        }
  74   1        else
  75   1        {
  76   2          PWMCR &= (~(1 << 6));
  77   2        }
  78   1        if (ENABLE == PWMx->PWM_OUT_EN)              //ENABLE=PWMÍ¨µÀxµÄ¶Ë¿ÚÎªPWM²¨ÐÎÊä³ö¿Ú ÊÜPWM²¨ÐÎ·¢ÉúÆ÷¿ØÖÆ
  79   1        {
  80   2          PWMCR |= (1 << PWM_N);
  81   2        }
  82   1        else
  83   1        {
  84   2          PWMCR &= (~(1 << PWM_N));
  85   2        }
  86   1        if (ENABLE == PWMx->PWM_UNUSUAL_EN)          //ENABLE=Ê¹ÄÜPWMµÄÍâ²¿Òì³£¼ì²â¹¦ÄÜ
  87   1        {
  88   2          PWMFDCR = (1 << 5);
  89   2        }
  90   1        else
  91   1        {
  92   2          PWMFDCR &= (~(1 << 5));
  93   2        }
  94   1        if (ENABLE == PWMx->PWM_UNUSUAL_OUT)         //ENABLE=·¢ÉúÒì³£Ê±£¬PWM¶ÔÓ¦µÄÊä³ö¿Ú»á±ä³É ¸ß×èÊäÈëÄ£Ê½
  95   1        {
  96   2          PWMFDCR = (1 << 4);
  97   2        }
  98   1        else
  99   1        {
 100   2          PWMFDCR &= (~(1 << 4));
 101   2        }
 102   1        if (ENABLE == PWMx->PWM_UNUSUAL_ISR_EN)      //ENABLE=Ê¹ÄÜÒì³£¼ì²âÖÐ¶Ï DISABLE=¹Ø±ÕÒì³£¼ì²âÖÐ¶Ï µ«FDIFÈÔÈ
             -»»á±»Ó²¼þÖÃÎ»
 103   1        {
 104   2          PWMFDCR = (1 << 3);
 105   2        }
 106   1        else
 107   1        {
 108   2          PWMFDCR &= (~(1 << 3));
 109   2        }
 110   1        if (ENABLE == PWMx->PWM_UNUSUAL_CMP0_EN)     //ENABLE=Òì³£¼ì²âÔ´Îª±È½ÏÆ÷µÄÊä³ö µ±±È½Ï½á¹ûÎª¸ßÊ± ´¥·¢PWMÒì
             -³£
 111   1        {
 112   2          PWMFDCR = (1 << 2);
 113   2        }
C51 COMPILER V8.05a   STC15_PWM                                                            07/17/2017 11:46:44 PAGE 3   

 114   1        else
 115   1        {
 116   2          PWMFDCR &= (~(1 << 2));
 117   2        }
 118   1        if (ENABLE == PWMx->PWM_UNUSUAL_P24_EN)      //ENABLE=Òì³£¼ì²âÔ´ÎªP24/PWMFLT µ±P24=1 ´¥·¢PWMÒì³£
 119   1        {
 120   2          PWMFDCR = (1 << 1);
 121   2        }
 122   1        else
 123   1        {
 124   2          PWMFDCR &= (~(1 << 1));
 125   2        }
 126   1        //  PWMCKS=0;
 127   1        if (PWM_Clock_NT == PWMx->PWM_CLOCK)               //PWM_Clock_NT=PWMµÄÊ±ÖÓÔ´ÊÇÏµÍ³Ê±ÖÓ¾­·ÖÆµºóµÄÊ±ÖÓ  PW
             -M_Clock_Timer2_OF=PWMµÄÊ±ÖÓÔ´ÊÇTMER2µÄÒç³öÂö³å
 128   1        {
 129   2          PWMCKS &= (~(1 << 4));
 130   2        }
 131   1        else
 132   1        {
 133   2          PWMCKS |= (1 << 4);
 134   2        }
 135   1        // PWMCKS=0x00;
 136   1        PWMCKS |= PWMx->PWM_CLOCK_DIV;           //µ±PWM_CLOCK=PWM_Clock_NTÊ± PWMµÄÊ±ÖÓÔ´ÊÇÏµÍ³Ê±ÖÓ/(PS[3:0]+1)
 137   1        switch (PWM_N)
 138   1        {
 139   2        case PWM_2:
 140   2        {
 141   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
             -Ñ¡ÔñIO¿Ú
 142   3          {
 143   4            PWM2CR &= (~(1 << 3));
 144   4          }
 145   3          else
 146   3          {
 147   4            PWM2CR |= (1 << 3);
 148   4          }
 149   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
 150   3          {
 151   4            PWM2CR |= (1 << 2);
 152   4          }
 153   3          else
 154   3          {
 155   4            PWM2CR &= (~(1 << 2));
 156   4          }
 157   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 158   3          {
 159   4            PWM2CR |= (1 << 1);
 160   4          }
 161   3          else
 162   3          {
 163   4            PWM2CR &= (~(1 << 1));
 164   4          }
 165   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
 166   3          {
 167   4            PWM2CR |= (1 << 0);
 168   4          }
 169   3          else
 170   3          {
 171   4            PWM2CR &= (~(1 << 0));
 172   4          }
 173   3        }
C51 COMPILER V8.05a   STC15_PWM                                                            07/17/2017 11:46:44 PAGE 4   

 174   2        break;
 175   2        case PWM_3:
 176   2        {
 177   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
             -Ñ¡ÔñIO¿Ú
 178   3          {
 179   4            PWM3CR &= (~(1 << 3));
 180   4          }
 181   3          else
 182   3          {
 183   4            PWM3CR |= (1 << 3);
 184   4          }
 185   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
 186   3          {
 187   4            PWM3CR |= (1 << 2);
 188   4          }
 189   3          else
 190   3          {
 191   4            PWM3CR &= (~(1 << 2));
 192   4          }
 193   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 194   3          {
 195   4            PWM3CR |= (1 << 1);
 196   4          }
 197   3          else
 198   3          {
 199   4            PWM3CR &= (~(1 << 1));
 200   4          }
 201   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
 202   3          {
 203   4            PWM3CR |= (1 << 0);
 204   4          }
 205   3          else
 206   3          {
 207   4            PWM3CR &= (~(1 << 0));
 208   4          }
 209   3        }
 210   2        break;
 211   2        case PWM_4:
 212   2        {
 213   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
             -Ñ¡ÔñIO¿Ú
 214   3          {
 215   4            PWM4CR &= (~(1 << 3));
 216   4          }
 217   3          else
 218   3          {
 219   4            PWM4CR |= (1 << 3);
 220   4          }
 221   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
 222   3          {
 223   4            PWM4CR |= (1 << 2);
 224   4          }
 225   3          else
 226   3          {
 227   4            PWM4CR &= (~(1 << 2));
 228   4          }
 229   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 230   3          {
 231   4            PWM4CR |= (1 << 1);
 232   4          }
 233   3          else
C51 COMPILER V8.05a   STC15_PWM                                                            07/17/2017 11:46:44 PAGE 5   

 234   3          {
 235   4            PWM4CR &= (~(1 << 1));
 236   4          }
 237   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
 238   3          {
 239   4            PWM4CR |= (1 << 0);
 240   4          }
 241   3          else
 242   3          {
 243   4            PWM4CR &= (~(1 << 0));
 244   4          }
 245   3        }
 246   2        break;
 247   2        case PWM_5:
 248   2        {
 249   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
             -Ñ¡ÔñIO¿Ú
 250   3          {
 251   4            PWM5CR &= (~(1 << 3));
 252   4          }
 253   3          else
 254   3          {
 255   4            PWM5CR |= (1 << 3);
 256   4          }
 257   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
 258   3          {
 259   4            PWM5CR |= (1 << 2);
 260   4          }
 261   3          else
 262   3          {
 263   4            PWM5CR &= (~(1 << 2));
 264   4          }
 265   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 266   3          {
 267   4            PWM5CR |= (1 << 1);
 268   4          }
 269   3          else
 270   3          {
 271   4            PWM5CR &= (~(1 << 1));
 272   4          }
 273   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
 274   3          {
 275   4            PWM5CR |= (1 << 0);
 276   4          }
 277   3          else
 278   3          {
 279   4            PWM5CR &= (~(1 << 0));
 280   4          }
 281   3        }
 282   2        break;
 283   2        case PWM_6:
 284   2        {
 285   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
             -Ñ¡ÔñIO¿Ú
 286   3          {
 287   4            PWM6CR &= (~(1 << 3));
 288   4          }
 289   3          else
 290   3          {
 291   4            PWM6CR |= (1 << 3);
 292   4          }
 293   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
C51 COMPILER V8.05a   STC15_PWM                                                            07/17/2017 11:46:44 PAGE 6   

 294   3          {
 295   4            PWM6CR |= (1 << 2);
 296   4          }
 297   3          else
 298   3          {
 299   4            PWM6CR &= (~(1 << 2));
 300   4          }
 301   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 302   3          {
 303   4            PWM6CR |= (1 << 1);
 304   4          }
 305   3          else
 306   3          {
 307   4            PWM6CR &= (~(1 << 1));
 308   4          }
 309   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
 310   3          {
 311   4            PWM6CR |= (1 << 0);
 312   4          }
 313   3          else
 314   3          {
 315   4            PWM6CR &= (~(1 << 0));
 316   4          }
 317   3        }
 318   2        break;
 319   2        case PWM_7:
 320   2        {
 321   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
             -Ñ¡ÔñIO¿Ú
 322   3          {
 323   4            PWM7CR &= (~(1 << 3));
 324   4          }
 325   3          else
 326   3          {
 327   4            PWM7CR |= (1 << 3);
 328   4          }
 329   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
 330   3          {
 331   4            PWM7CR |= (1 << 2);
 332   4          }
 333   3          else
 334   3          {
 335   4            PWM7CR &= (~(1 << 2));
 336   4          }
 337   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 338   3          {
 339   4            PWM7CR |= (1 << 1);
 340   4          }
 341   3          else
 342   3          {
 343   4            PWM7CR &= (~(1 << 1));
 344   4          }
 345   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
 346   3          {
 347   4            PWM7CR |= (1 << 0);
 348   4          }
 349   3          else
 350   3          {
 351   4            PWM7CR &= (~(1 << 0));
 352   4          }
 353   3        }
 354   2        break;
C51 COMPILER V8.05a   STC15_PWM                                                            07/17/2017 11:46:44 PAGE 7   

 355   2        default:
 356   2          //      return 1;
 357   2          break;
 358   2        }
 359   1        if (ENABLE == PWMx->PWM_EN)                  //ENABLE=PWMÊ¹ÄÜ ÔÚÆäËûPWM²ÎÊýÉèÖÃºÃºó×îºóÉèÖÃ Èç¹û±»¹Ø±ÕºóÔ
             -Ú´ò¿ª£¬ÔòPWM¼ÆÊýÆ÷ÖØÐÂ´Ó0¼ÆÊý
 360   1        {
 361   2          PWMCR |= (1 << 7);
 362   2        }
 363   1        else
 364   1        {
 365   2          PWMCR &= (~(1 << 7));
 366   2        }
 367   1      }
 368          /*************************************************
 369          * º¯ÊýÃû³Æ: u32 getPWM_period(void )
 370          * ÃèÊö: ·µ»ØËùÉèÖÃµÄpwmÆµÂÊÐÅÏ¢
 371          * ÊäÈë: u8 PWM_N, 2<=N<=7
 372          * Êä³ö: ÎÞ
 373          * ·µ»ØÖµ: pwmÆµÂÊ
 374          * ÆäËûËµÃ÷: ÈôÃ»ÓÐÉèÖÃpwmµÄÆµÂÊ¾Íµ÷ÓÃ´Ëº¯ÊýÔò»á·µ»Ø0£»
 375          *************************************************/
 376          u32 get_PWM_period(u8 PWM_N)
 377          {
 378   1        return PWM_N_INFO[PWM_N].period;
 379   1      }
 380          /*************************************************
 381          * º¯ÊýÃû³Æ: float getPWM_n_duty(u8 PWM_N)
 382          * ÃèÊö: ·µ»ØPWM_NµÄÕ¼¿Õ±ÈÐÅÏ¢
 383          * ÊäÈë: u8 PWM_N, 2<=N<=7
 384          * Êä³ö: ÎÞ
 385          * ·µ»ØÖµ: PWM_NµÄÕ¼¿Õ±ÈÐÅÏ¢,floatÐÎÊ½
 386          * ÆäËûËµÃ÷: ÈôÃ»ÓÐÉèÖÃpwmµÄÕ¼¿Õ±È¾Íµ÷ÓÃ´Ëº¯ÊýÔò»á·µ»Ø0£»
 387          *************************************************/
 388          float get_PWM_N_duty(u8 PWM_N)
 389          {
 390   1        return  PWM_N_INFO[PWM_N].duty;
 391   1      }
 392          
 393          /*************************************************
 394          * º¯ÊýÃû³Æ:void PWM_period(u16 Hz)
 395          * ÃèÊö: ÉèÖÃÓ²¼þpwmµÄÍ¬Ò»ÆµÂÊ £¬²¢±£´æÆµÂÊÊý¾Ý
 396          * ±»±¾º¯Êýµ÷ÓÃµÄº¯Êý:
 397          * 1.PWM_SET_PERIOD
 398          * ÊäÈë:u16 Hz:ÒªÊä³öµÄpwmµÄÆµÂÊ,ÓÉÓÚÓ²¼þËùÏÞ£¬½«»áÍ¬Ê±¸Ä±ä6Â·pwmµÄÆµÂÊ
 399          * Êä³ö: ÎÞ
 400          * ·µ»ØÖµ: ÎÞ
 401          * ÆäËû: ´Ëº¯ÊýÖ»ÄÜÉèÖÃpwmµÄ¼ÆÊýÆ÷³õÊ¼Öµ£¬´Ó¶øÍê³Épwm²»Í¬ÆµÂÊµÄÊä³ö£¬
 402              µ«ÊÇÓÉÓÚµ¥Æ¬»úÓ²¼þËùÏÞ£¬²»¿ÉÒÔµ¥¶À¶ÔÃ¿Â·pwmµÄÆµÂÊ½øÐÐÐÞ¸Ä£¬
 403              Ö»ÄÜÒ»¸ÄÈ«¸Ä¡£
 404          *************************************************/
 405          void set_PWM_period(u8 PWM_N,u16 Hz)
 406          {
 407   1        PWM_N_INFO[PWM_N].period = Hz;
 408   1        PWM_UNLOCK;
 409   1        PWM_ALL_NO;
 410   1        PWM_SET_PERIOD((u16)(MAIN_Fosc/(Hz*16)));
 411   1      //  PWM_ALL_EN;
 412   1        PWM_LOCK;
 413   1        
 414   1          
 415   1      }
C51 COMPILER V8.05a   STC15_PWM                                                            07/17/2017 11:46:44 PAGE 8   

 416          
 417          /*************************************************
 418          * º¯ÊýÃû³Æ: void PWM_duty(u8 PWM_N,float duty)
 419          * ÃèÊö: ÐÞ¸ÄÄ³Ò»Â·pwmµÄÕ¼¿Õ±È £¬²¢±£´æÕ¼¿Õ±ÈÊý¾Ý
 420          * ±»±¾º¯Êýµ÷ÓÃµÄº¯Êý:
 421          * µ÷ÓÃ±¾º¯ÊýµÄº¯Êý:
 422          * ÊäÈë:
 423          * 1.u8 PWM_N £º ÄÄÒ»Â·pwm
 424          * 2.float duty£ºÕ¼¿Õ±È£¬Ê¹ÓÃÐ¡Êý£¬Èç0.8´ú±í80%µÄÕ¼¿Õ±È
 425          * Êä³ö: ÎÞ
 426          * ·µ»ØÖµ: ÎÞ
 427          * ÆäËûËµÃ÷:Îª·ÀÖ¹µçÆ½·¢Éú·´×ª£¬ÏÞÖÆ×îÐ¡Õ¼¿Õ±ÈÎª0.05£¬×î´óÎª0.95
 428          *************************************************/
 429          void set_PWM_duty(u8 PWM_N, float duty)
 430          {
 431   1        if (duty > 0.95f)
 432   1        {
 433   2          duty = 0.95f;
 434   2        }
 435   1        if (duty < 0.05f)
 436   1        {
 437   2          duty = 0.05f;
 438   2        }
 439   1        PWM_N_INFO[PWM_N].duty = duty;//´æ´¢Õ¼¿Õ±ÈÖµ
 440   1        PWM_UNLOCK;
 441   1        PWM_SET_T12_PERIOD(PWM_N, 0, (PWM_N_INFO[PWM_N].duty *(MAIN_Fosc/(PWM_N_INFO[PWM_N].period*16))));
 442   1        PWM_LOCK;
 443   1      }
 444          void open_PWM_ALL(void)
 445          {
 446   1        PWM_UNLOCK;
 447   1        PWM_ALL_EN;
 448   1        PWM_LOCK;
 449   1      }
 450          void close_PWM_ALL(void)
 451          {
 452   1        PWM_UNLOCK;
 453   1        PWM_ALL_NO; //×Ü¿ª¹Ø
 454   1        PWM_LOCK;
 455   1      
 456   1      }
 457          void open_PWM_N(u8 PWM_N)
 458          {
 459   1        PWM_UNLOCK;
 460   1        PWM_N_EN(PWM_N);
 461   1        PWM_N_INFO[PWM_N].state = ON;
 462   1        PWM_ALL_EN; //×Ü¿ª¹Ø
 463   1        PWM_LOCK;
 464   1      
 465   1      
 466   1      }
 467          void close_PWM_N(u8 PWM_N)
 468          {
 469   1        PWM_UNLOCK;
 470   1        PWM_N_NO(PWM_N);
 471   1        PWM_N_INFO[PWM_N].state = OFF;
 472   1        PWM_LOCK;
 473   1      
 474   1      }
 475          bit get_PWM_N_state(u8 PWM_N)
 476          {
 477   1      
C51 COMPILER V8.05a   STC15_PWM                                                            07/17/2017 11:46:44 PAGE 9   

 478   1        return  PWM_N_INFO[PWM_N].state;
 479   1      }
 480          
 481          //////////////ÒÔÏÂÎªË½ÓÐº¯Êý£¬²»½¨Òé¸Ä¶¯//////////////////////
 482          //
 483          //************************************
 484          // Method:    PWM_SET_PERIOD
 485          // FullName:  PWM_SET_PERIOD
 486          // Access:    public static 
 487          // Returns:   u8
 488          // Qualifier: ÉèÖÃPWMÖÜÆÚ
 489          // Parameter: u16 period
 490          //************************************
 491          static u8 PWM_SET_PERIOD(u16 period)
 492          {
 493   1        if (0x8000 > period)
 494   1        {
 495   2          PWMCL = (u8)(period);
 496   2          PWMCH = (u8)(period >> 8);
 497   2          return 0;
 498   2        }
 499   1        else
 500   1        {
 501   2          return 1;
 502   2        }
 503   1      }
 504          
 505          //
 506          //************************************
 507          // Method:    PWM_SET_T12_PERIOD
 508          // FullName:  PWM_SET_T12_PERIOD
 509          // Access:    public static 
 510          // Returns:   u8
 511          // Qualifier: ÉèÖÃPWMµÚÒ»´ÎºÍµÚ¶þ´Î·­×ªÖÜÆÚ
 512          // Parameter: u8 PWM_N
 513          // Parameter: u16 period1
 514          // Parameter: u32 period2
 515          //************************************
 516          static u8 PWM_SET_T12_PERIOD(u8 PWM_N, u16 period1, u32 period2)
 517          {
 518   1        switch (PWM_N)
 519   1        {
 520   2        case PWM_2:
 521   2          PWM2T1L = (u8)(period1);
 522   2          PWM2T1H = (u8)(period1 >> 8);
 523   2          PWM2T2L = (u8)(period2);
 524   2          PWM2T2H = (u8)(period2 >> 8);
 525   2          return 0;
 526   2          break;
 527   2        case PWM_3:
 528   2          PWM3T1L = (u8)(period1);
 529   2          PWM3T1H = (u8)(period1 >> 8);
 530   2          PWM3T2L = (u8)(period2);
 531   2          PWM3T2H = (u8)(period2 >> 8);
 532   2          return 0;
 533   2          break;
 534   2        case PWM_4:
 535   2          PWM4T1L = (u8)(period1);
 536   2          PWM4T1H = (u8)(period1 >> 8);
 537   2          PWM4T2L = (u8)(period2);
 538   2          PWM4T2H = (u8)(period2 >> 8);
 539   2          return 0;
C51 COMPILER V8.05a   STC15_PWM                                                            07/17/2017 11:46:44 PAGE 10  

 540   2          break;
 541   2        case PWM_5:
 542   2          PWM5T1L = (u8)(period1);
 543   2          PWM5T1H = (u8)(period1 >> 8);
 544   2          PWM5T2L = (u8)(period2);
 545   2          PWM5T2H = (u8)(period2 >> 8);
 546   2          return 0;
 547   2          break;
 548   2        case PWM_6:
 549   2          PWM6T1L = (u8)(period1);
 550   2          PWM6T1H = (u8)(period1 >> 8);
 551   2          PWM6T2L = (u8)(period2);
 552   2          PWM6T2H = (u8)(period2 >> 8);
 553   2          return 0;
 554   2          break;
 555   2        case PWM_7:
 556   2          PWM7T1L = (u8)(period1);
 557   2          PWM7T1H = (u8)(period1 >> 8);
 558   2          PWM7T2L = (u8)(period2);
 559   2          PWM7T2H = (u8)(period2 >> 8);
 560   2          return 0;
 561   2          break;
 562   2        default:
 563   2          return 1;
 564   2          break;
 565   2        }
 566   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1720    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     54      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
